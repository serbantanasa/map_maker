"""Portions generated by AI with human review.

Coarse tectonic signal generation used as a sidecar for future world layers."""

from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Dict

import numpy as np


@dataclass(slots=True)
class TectonicField:
    plate_id: np.ndarray
    convergence: np.ndarray
    divergence: np.ndarray
    shear: np.ndarray
    metadata: Dict[str, object]


DIRS4 = ((-1, 0), (1, 0), (0, -1), (0, 1))


def generate_tectonic_field(
    width: int,
    height: int,
    seed: int,
    *,
    num_plates: int = 12,
    wrap_x: bool = False,
    wrap_y: bool = False,
) -> TectonicField:
    """Produce a coarse tectonic plate layout with simple velocity interactions."""

    rng = np.random.default_rng(seed)
    plate_centers = rng.uniform(low=[0.0, 0.0], high=[width, height], size=(num_plates, 2))
    plate_velocities = rng.normal(scale=1.0, size=(num_plates, 2)).astype(np.float32)

    yy, xx = np.mgrid[0:height, 0:width]
    grid = np.stack([xx, yy], axis=-1).astype(np.float32)

    # Assign nearest plate center (Voronoi)
    # vectorized distance computation
    diff = grid[..., None, :] - plate_centers[None, None, :, :]
    dist = np.linalg.norm(diff, axis=-1)
    plate_idx = dist.argmin(axis=-1).astype(np.int16)

    velocities = plate_velocities[plate_idx]

    convergence = np.zeros((height, width), dtype=np.float32)
    divergence = np.zeros_like(convergence)
    shear = np.zeros_like(convergence)

    for dy, dx in DIRS4:
        neighbor_plate = np.roll(plate_idx, shift=(-dy, -dx), axis=(0, 1))
        neighbor_vel = np.roll(velocities, shift=(-dy, -dx), axis=(0, 1))

        mask = plate_idx != neighbor_plate

        if not wrap_y:
            if dy == -1:
                mask[0, :] = False
            elif dy == 1:
                mask[-1, :] = False
        if not wrap_x:
            if dx == -1:
                mask[:, 0] = False
            elif dx == 1:
                mask[:, -1] = False

        if not np.any(mask):
            continue

        dir_vec = np.array([float(dx), float(dy)], dtype=np.float32)
        norm = np.linalg.norm(dir_vec)
        if norm == 0:
            continue
        dir_unit = dir_vec / norm

        rel = np.sum((neighbor_vel - velocities) * dir_unit, axis=-1)
        normal_pos = np.where(mask & (rel > 0), rel, 0.0)
        normal_neg = np.where(mask & (rel < 0), -rel, 0.0)

        convergence += normal_pos
        divergence += normal_neg

        shear_vec = (neighbor_vel - velocities) - rel[..., None] * dir_unit
        shear += np.where(mask, np.linalg.norm(shear_vec, axis=-1), 0.0)

    convergence *= 0.5
    divergence *= 0.5
    shear *= 0.5

    metadata = {
        "seed": seed,
        "num_plates": int(num_plates),
        "wrap_x": wrap_x,
        "wrap_y": wrap_y,
        "plate_centers": plate_centers.tolist(),
        "plate_velocities": plate_velocities.tolist(),
    }

    return TectonicField(
        plate_id=plate_idx,
        convergence=convergence,
        divergence=divergence,
        shear=shear,
        metadata=metadata,
    )


def save_tectonic_field(field: TectonicField, path: str | Path) -> None:
    """Persist the tectonic sidecar as a compressed NPZ plus metadata JSON."""

    path = Path(path)
    arrays_path = path if path.suffix else path.with_suffix(".npz")
    arrays_path.parent.mkdir(parents=True, exist_ok=True)

    np.savez_compressed(
        arrays_path,
        plate_id=field.plate_id.astype(np.int16),
        convergence=field.convergence.astype(np.float32),
        divergence=field.divergence.astype(np.float32),
        shear=field.shear.astype(np.float32),
    )

    meta_path = arrays_path.with_suffix(".json")
    with meta_path.open("w", encoding="utf-8") as fh:
        json.dump(field.metadata, fh, indent=2)
