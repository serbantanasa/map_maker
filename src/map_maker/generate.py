"""Portions generated by AI with human review.

Procedural world generation utilities."""

from __future__ import annotations

import math
import json
from collections import deque
from pathlib import Path
from typing import Any, Dict, List, Tuple

import numpy as np
from noise import pnoise2
from PIL import Image
from shapely.geometry import LineString

from map_maker.core.hydrology import (
    build_hydrosurface,
    breach_endorheic_basins,
    flow_accumulation,
    flowdir_d8,
    label_basins,
    label_lakes,
    priority_flood_fill,
)
from map_maker.io.geo import world_transform, write_geotiff, write_parquet_wkb

Array = np.ndarray

D8_OFFSETS: Tuple[Tuple[int, int], ...] = (
    (-1, -1),
    (-1, 0),
    (-1, 1),
    (0, -1),
    (0, 1),
    (1, -1),
    (1, 0),
    (1, 1),
)
D8_DY = np.array([dy for dy, _ in D8_OFFSETS], dtype=np.int8)
D8_DX = np.array([dx for _, dx in D8_OFFSETS], dtype=np.int8)


def _flat_to_dir_indices(flat_dir: np.ndarray) -> np.ndarray:
    """Convert downstream flat indices to D8 direction codes (-1 for sinks)."""
    h, w = flat_dir.shape
    dirs = np.full((h, w), -1, dtype=np.int8)
    for y in range(h):
        for x in range(w):
            target = int(flat_dir[y, x])
            if target < 0:
                continue
            ny, nx = divmod(target, w)
            dy = ny - y
            dx = nx - x
            for idx, (oy, ox) in enumerate(D8_OFFSETS):
                if oy == dy and ox == dx:
                    dirs[y, x] = idx
                    break
    return dirs


def _count_upstream(direction_idx: np.ndarray) -> np.ndarray:
    """Return the number of incoming rivers for each cell."""
    h, w = direction_idx.shape
    upstream = np.zeros((h, w), dtype=np.int8)
    for y in range(h):
        for x in range(w):
            idx = int(direction_idx[y, x])
            if idx >= 0:
                ny = y + int(D8_DY[idx])
                nx = x + int(D8_DX[idx])
                if 0 <= ny < h and 0 <= nx < w:
                    upstream[ny, nx] += 1
    return upstream


def _perlin(width: int, height: int, scale: float, octaves: int, seed: int) -> Array:
    """Return Perlin noise in [-1,1]."""
    arr = np.empty((height, width), dtype=np.float32)
    freq = 1.0 / max(1.0, scale)
    for y in range(height):
        for x in range(width):
            arr[y, x] = pnoise2(
                x * freq,
                y * freq,
                octaves=octaves,
                repeatx=1 << 16,
                repeaty=1 << 16,
                base=seed,
            )
    return arr


def _normalize(a: Array, lo: float, hi: float) -> Array:
    amin, amax = float(a.min()), float(a.max())
    if amax == amin:
        return np.full_like(a, (lo + hi) / 2.0, dtype=np.float32)
    b = (a - amin) / (amax - amin)
    return (lo + b * (hi - lo)).astype(np.float32)


def _radial_falloff(width: int, height: int, power: float = 3.0) -> Array:
    """0 at center, 1 at corners; raise to power to shape."""
    cx, cy = (width - 1) / 2.0, (height - 1) / 2.0
    maxd = math.hypot(cx, cy)
    yy, xx = np.ogrid[:height, :width]
    d = np.hypot(xx - cx, yy - cy) / maxd
    return np.clip(d**power, 0.0, 1.0).astype(np.float32)


def make_elevation(width: int, height: int, seed: int, cfg: Dict) -> Array:
    n1 = _perlin(
        width,
        height,
        cfg.get("elev_scale", 300.0),
        cfg.get("elev_octaves", 6),
        seed,
    )
    n2 = _perlin(
        width,
        height,
        cfg.get("elev_scale2", 80.0),
        cfg.get("elev_octaves2", 3),
        seed + 101,
    )
    base = 0.7 * n1 + 0.3 * n2
    base = _normalize(base, -1.0, 1.0)
    fall = _radial_falloff(width, height, cfg.get("falloff_power", 2.6))
    elev = base - (cfg.get("falloff_strength", 0.6) * fall)
    return _normalize(elev, -1.0, 1.0)


def make_temperature(width: int, height: int, elev: Array, cfg: Dict) -> Array:
    # Latitude gradient: equator in the middle (y=H/2).
    yy = np.linspace(-1.0, 1.0, height, dtype=np.float32).reshape(height, 1)
    lat = 1.0 - np.abs(yy)  # 1 at equator, 0 at poles
    lapse = cfg.get("temp_lapse", 0.45)  # how much elevation cools
    temp = lat - (np.clip(elev, -1, 1) + 1.0) * 0.5 * lapse
    return np.clip(temp, 0.0, 1.0).astype(np.float32)


def make_moisture(width: int, height: int, seed: int, elev: Array, cfg: Dict) -> Array:
    m = _perlin(
        width,
        height,
        cfg.get("moist_scale", 220.0),
        cfg.get("moist_octaves", 4),
        seed + 202,
    )
    m = _normalize(m, 0.0, 1.0)
    # Boost moisture near coasts (cheap heuristic): blur ocean mask once.
    ocean = elev < cfg.get("ocean_level", 0.0)
    ocean_u8 = ocean.astype(np.uint8)
    # 3x3 box blur to approximate proximity
    prox = ocean_u8.astype(np.float32)
    prox = (
        prox
        + np.pad(prox[1:], ((0, 1), (0, 0)))  # up
        + np.pad(prox[:-1], ((1, 0), (0, 0)))  # down
        + np.pad(prox[:, 1:], ((0, 0), (0, 1)))  # right
        + np.pad(prox[:, :-1], ((0, 0), (1, 0)))  # left
    ) / 5.0
    boost = cfg.get("coast_moist_boost", 0.25) * prox
    moist = np.clip(m + boost, 0.0, 1.0)
    return moist


def classify_biomes(temp: Array, moist: Array) -> Array:
    """
    Simple Whittaker-like classification.
    0: ocean (fill later), 1: tundra, 2: boreal, 3: temperate grass,
    4: temperate forest, 5: savanna, 6: tropical dry, 7: tropical rainforest,
    8: desert, 9: montane
    """
    b = np.zeros_like(temp, dtype=np.uint8)
    # Start with dryness
    desert = (moist < 0.18) & (temp > 0.25)
    tundra = temp < 0.18
    boreal = (~tundra) & (temp < 0.35) & (moist > 0.35)
    temperate_forest = (temp >= 0.35) & (temp < 0.65) & (moist >= 0.45)
    temperate_grass = (temp >= 0.35) & (temp < 0.65) & (moist < 0.45) & ~desert
    savanna = (temp >= 0.65) & (moist >= 0.25) & (moist < 0.50)
    tropical_rain = (temp >= 0.65) & (moist >= 0.50)
    tropical_dry = (temp >= 0.65) & (moist >= 0.18) & (moist < 0.25)
    b[desert] = 8
    b[tundra] = 1
    b[boreal] = 2
    b[temperate_grass] = 3
    b[temperate_forest] = 4
    b[savanna] = 5
    b[tropical_dry] = 6
    b[tropical_rain] = 7
    # crude montane override (cold due to height)
    b[temp < 0.22] = 1
    return b


def compute_stream_orders(
    flow_dir: np.ndarray,
    upstream: np.ndarray,
) -> Tuple[np.ndarray, np.ndarray]:
    """Compute Strahler and Shreve orders for each cell."""
    h, w = flow_dir.shape
    indegree = upstream.astype(np.int16)
    strahler = np.zeros_like(flow_dir, dtype=np.uint8)
    shreve = np.zeros_like(flow_dir, dtype=np.uint32)
    max_order = np.zeros_like(flow_dir, dtype=np.uint8)
    max_count = np.zeros_like(flow_dir, dtype=np.uint8)
    shreve_sum = np.zeros_like(flow_dir, dtype=np.uint32)
    queue: deque[Tuple[int, int]] = deque()

    for y in range(h):
        for x in range(w):
            if indegree[y, x] == 0:
                strahler[y, x] = 1
                shreve[y, x] = 1
                queue.append((y, x))

    while queue:
        y, x = queue.popleft()
        dir_idx = flow_dir[y, x]
        if dir_idx < 0:
            continue
        ny = y + int(D8_DY[dir_idx])
        nx = x + int(D8_DX[dir_idx])
        if not (0 <= ny < h and 0 <= nx < w):
            continue
        shreve_sum[ny, nx] += shreve[y, x]
        current = strahler[y, x]
        if current > max_order[ny, nx]:
            max_order[ny, nx] = current
            max_count[ny, nx] = 1
        elif current == max_order[ny, nx]:
            max_count[ny, nx] += 1
        indegree[ny, nx] = max(indegree[ny, nx] - 1, 0)
        if indegree[ny, nx] == 0:
            new_order = max_order[ny, nx]
            if new_order == 0:
                new_order = 1
            if max_count[ny, nx] >= 2:
                new_order += 1
            strahler[ny, nx] = new_order
            shreve_val = shreve_sum[ny, nx]
            shreve[ny, nx] = shreve_val if shreve_val > 0 else 1
            queue.append((ny, nx))

    # Ensure every cell has at least order 1
    strahler[strahler == 0] = 1
    shreve[shreve == 0] = 1
    return strahler, shreve


def cell_center_lonlat(x: int, y: int, width: int, height: int) -> Tuple[float, float]:
    dx = 360.0 / float(width)
    dy = 180.0 / float(height)
    lon = -180.0 + (x + 0.5) * dx
    lat = 90.0 - (y + 0.5) * dy
    return lon, lat


def haversine_km(lon1: float, lat1: float, lon2: float, lat2: float) -> float:
    """Approximate great-circle distance in kilometers."""
    rad = math.radians
    phi1, phi2 = rad(lat1), rad(lat2)
    dphi = rad(lat2 - lat1)
    dlambda = rad(lon2 - lon1)
    a = (
        math.sin(dphi / 2.0) ** 2
        + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda / 2.0) ** 2
    )
    return 2.0 * 6371.0 * math.asin(math.sqrt(a))


def cell_area_km2(lat: float, width: int, height: int) -> float:
    dx = 360.0 / float(width)
    dy = 180.0 / float(height)
    earth_radius = 6371.0
    lat_rad = math.radians(lat)
    return (
        (earth_radius**2)
        * math.radians(dx)
        * math.radians(dy)
        * max(math.cos(lat_rad), 1e-3)
    )


def _smooth_polyline(points: List[Tuple[float, float]], iterations: int = 2) -> List[Tuple[float, float]]:
    pts = [np.array(p, dtype=np.float32) for p in points]
    for _ in range(iterations):
        if len(pts) < 3:
            break
        new_pts = [pts[0]]
        for a, b in zip(pts, pts[1:]):
            q = 0.75 * a + 0.25 * b
            r = 0.25 * a + 0.75 * b
            new_pts.extend([q, r])
        new_pts.append(pts[-1])
        pts = new_pts
    return [(float(p[0]), float(p[1])) for p in pts]


def _jitter_polyline(
    points: List[Tuple[float, float]],
    dx: float,
    dy: float,
    seed: int,
    intensity: float = 0.35,
) -> List[Tuple[float, float]]:
    if len(points) <= 2:
        return points
    jittered = [points[0]]
    cell_lon = dx * intensity
    cell_lat = dy * intensity
    for idx, (lon, lat) in enumerate(points[1:-1], start=1):
        key = (seed * 1315423911) ^ (idx * 2654435761)
        rng = np.random.default_rng(key & ((1 << 63) - 1))
        offset_lon = (rng.random() - 0.5) * cell_lon
        offset_lat = (rng.random() - 0.5) * cell_lat
        jittered.append((lon + offset_lon, lat + offset_lat))
    jittered.append(points[-1])
    return jittered


def extract_river_segments(
    flow_acc: Array,
    flow_dir: np.ndarray,
    strahler: np.ndarray,
    shreve: np.ndarray,
    basins: np.ndarray,
    lake_ids: np.ndarray,
    ocean_mask: np.ndarray,
    river_mask: np.ndarray,
    *,
    seed: int,
) -> Dict[str, List]:
    """Extract polyline segments for rivers using D8 directions."""
    h, w = flow_acc.shape
    river_mask = river_mask.astype(bool)
    if not river_mask.any():
        return {
            "geoms": [],
            "basin_id": [],
            "order_strahler": [],
            "order_shreve": [],
            "discharge": [],
            "length_km": [],
            "source_type": [],
            "mouth_type": [],
        }

    upstream_mask = np.zeros_like(flow_dir, dtype=np.int8)
    for y in range(h):
        for x in range(w):
            if not river_mask[y, x]:
                continue
            dir_idx = flow_dir[y, x]
            if dir_idx < 0:
                continue
            ny = y + int(D8_DY[dir_idx])
            nx = x + int(D8_DX[dir_idx])
            if 0 <= ny < h and 0 <= nx < w and river_mask[ny, nx]:
                upstream_mask[ny, nx] += 1

    started = np.zeros_like(river_mask, dtype=bool)
    geoms: List[LineString] = []
    basin_ids: List[int] = []
    strahler_orders: List[int] = []
    shreve_orders: List[int] = []
    discharges: List[float] = []
    lengths: List[float] = []
    source_types: List[str] = []
    mouth_types: List[str] = []

    for y in range(h):
        for x in range(w):
            if not river_mask[y, x]:
                continue
            if started[y, x]:
                continue
            upstream_count = int(upstream_mask[y, x])
            if upstream_count == 1:
                # This segment will be covered by an upstream start.
                continue
            started[y, x] = True
            segment_cells: List[Tuple[int, int]] = []
            local_seen = set()
            cy, cx = y, x
            mouth_type = "endorheic"
            while True:
                if (cy, cx) in local_seen:
                    break
                local_seen.add((cy, cx))
                segment_cells.append((cy, cx))
                dir_idx = flow_dir[cy, cx]
                if dir_idx < 0:
                    mouth_type = "endorheic"
                    break
                ny = cy + int(D8_DY[dir_idx])
                nx = cx + int(D8_DX[dir_idx])
                if not (0 <= ny < h and 0 <= nx < w):
                    mouth_type = "endorheic"
                    break
                if ocean_mask[ny, nx]:
                    segment_cells.append((ny, nx))
                    mouth_type = "ocean"
                    break
                if lake_ids[ny, nx] > 0:
                    segment_cells.append((ny, nx))
                    mouth_type = "lake"
                    break
                if not river_mask[ny, nx]:
                    segment_cells.append((ny, nx))
                    mouth_type = "endorheic"
                    break
                upstream_next = int(upstream_mask[ny, nx])
                segment_cells.append((ny, nx))
                if upstream_next != 1:
                    started[ny, nx] = True
                    break
                cy, cx = int(ny), int(nx)

            if len(segment_cells) < 2:
                continue

            coords = [cell_center_lonlat(cx, cy, w, h) for cy, cx in segment_cells]
            # Remove consecutive duplicate points
            dedup_coords = [coords[0]]
            for lon, lat in coords[1:]:
                if (lon, lat) != dedup_coords[-1]:
                    dedup_coords.append((lon, lat))
            if len(dedup_coords) < 2:
                continue

            smoothed = _smooth_polyline(dedup_coords, iterations=2)
            jittered = _jitter_polyline(smoothed, 360.0 / w, 180.0 / h, seed)
            geom = LineString(jittered)
            geoms.append(geom)
            seg_basin = int(basins[y, x])
            basin_ids.append(seg_basin)

            in_mask_cells = [
                (cy, cx) for cy, cx in segment_cells if river_mask[cy, cx]
            ]
            rows, cols = zip(*in_mask_cells)
            strahler_orders.append(int(np.max(strahler[rows, cols])))
            down_y, down_x = in_mask_cells[-1]
            shreve_orders.append(int(shreve[down_y, down_x]))

            length = 0.0
            for (lon1, lat1), (lon2, lat2) in zip(dedup_coords, dedup_coords[1:]):
                length += haversine_km(lon1, lat1, lon2, lat2)
            lengths.append(length)

            mouth_types.append(mouth_type)

            _, down_lat = cell_center_lonlat(down_x, down_y, w, h)
            area = cell_area_km2(down_lat, w, h)
            discharges.append(float(flow_acc[down_y, down_x]) * area)

            if upstream_count == 0:
                source_types.append("spring")
            elif lake_ids[y, x] > 0:
                source_types.append("lake_outlet")
            elif upstream_count >= 2:
                source_types.append("confluence")
            else:
                source_types.append("spring")

    return {
        "geoms": geoms,
        "basin_id": basin_ids,
        "order_strahler": strahler_orders,
        "order_shreve": shreve_orders,
        "discharge": discharges,
        "length_km": lengths,
        "source_type": source_types,
        "mouth_type": mouth_types,
    }


def render_png(world: Dict[str, Array], mode: str = "elevation") -> Image.Image:
    elev = world["elev"]
    temp = world["temp"]
    biomes = world["biome"]
    river_mask = world["rivers_mask"].astype(bool)
    ocean_level = world["params"]["ocean_level"]
    ice_threshold = world["params"]["ice_temp_threshold"]

    ocean = elev < ocean_level
    ice = temp <= ice_threshold
    lake_id = world["lake_id"]

    h, w = elev.shape
    img = np.zeros((h, w, 3), dtype=np.uint8)

    ocean_colors = [(56, 89, 138), (38, 64, 102), (23, 43, 71)]
    biome_colors = {
        1: (200, 220, 230),  # tundra
        2: (100, 140, 110),  # boreal
        3: (180, 200, 120),  # temp grass
        4: (80, 140, 80),  # temp forest
        5: (210, 200, 120),  # savanna
        6: (190, 170, 90),  # tropical dry
        7: (40, 120, 60),  # tropical rainforest
        8: (210, 180, 120),  # desert
    }

    depth = np.clip(-(elev - ocean_level), 0.0, 1.0)
    deep = depth > 0.66
    mid = (depth > 0.33) & ~deep
    shallow = (depth > 0.0) & ~deep & ~mid
    img[ocean & deep] = ocean_colors[2]
    img[ocean & mid] = ocean_colors[1]
    img[ocean & shallow] = ocean_colors[0]

    land = ~ocean
    if mode == "biome":
        for biome_id, color in biome_colors.items():
            img[(biomes == biome_id) & land] = color
    else:
        if land.any():
            elev_rel = elev[land]
            lo = float(elev_rel.min())
            hi = float(elev_rel.max())
            if hi - lo < 1e-6:
                elev_norm = np.zeros_like(elev_rel, dtype=np.float32)
            else:
                elev_norm = (elev_rel - lo) / (hi - lo)
            palette = np.array(
                [
                    (70, 120, 60),   # lowlands dark green
                    (200, 215, 160), # light green plains
                    (210, 190, 120), # yellow highlands
                    (160, 110, 90),  # brown foothills
                    (110, 60, 150),  # purple ridges
                    (70, 40, 120),   # highest peaks
                ],
                dtype=np.float32,
            )
            idx = np.clip((elev_norm * (len(palette) - 1)), 0, len(palette) - 1 - 1e-6)
            idx_floor = np.floor(idx).astype(int)
            frac = idx - idx_floor
            colors = (
                (1 - frac[:, None]) * palette[idx_floor]
                + frac[:, None] * palette[idx_floor + 1]
            ).astype(np.uint8)
            img[land] = colors

    lake_mask = lake_id > 0
    img[lake_mask] = (120, 170, 210)

    ice_mask = ice & (~ocean)
    img[ice_mask] = (235, 240, 245)

    rivers = river_mask & (~ice_mask) & (~ocean)
    img[rivers] = (30, 60, 120)

    return Image.fromarray(img, mode="RGB")


def generate_world(width: int, height: int, seed: int, config: Dict) -> Dict[str, Array | Dict]:
    params = {
        "ocean_level": float(config.get("ocean_level", 0.0)),
        "river_acc_min": int(config.get("river_acc_min", max(150, (width * height) // 6000))),
        "ice_temp_threshold": float(config.get("ice_temp_threshold", 0.12)),
        "coast_slope_eps": float(config.get("coast_slope_eps", 1e-3)),
    }

    elev = make_elevation(width, height, seed, config)
    temp = make_temperature(width, height, elev, config)
    moist = make_moisture(width, height, seed, elev, config)

    ocean_mask = elev < params["ocean_level"]
    ice_mask = temp <= params["ice_temp_threshold"]

    filled = priority_flood_fill(elev, ocean_mask=ocean_mask)
    hydro, dist_field = build_hydrosurface(
        filled, ocean_mask=ocean_mask, slope_eps=params["coast_slope_eps"]
    )
    flow_to = flowdir_d8(hydro, ocean_mask=ocean_mask, dist=dist_field)
    flow_acc = flow_accumulation(flow_to)
    lake_id = label_lakes(filled, elev, ocean_mask=ocean_mask)
    basin_id = label_basins(flow_to, ocean_mask=ocean_mask, lake_id=lake_id)

    breached = breach_endorheic_basins(
        flow_to,
        basin_id,
        ocean_mask,
        dist_field,
        hydro,
        flow_acc,
        params["river_acc_min"],
    )
    if breached:
        flow_acc = flow_accumulation(flow_to)
        basin_id = label_basins(flow_to, ocean_mask=ocean_mask, lake_id=lake_id)

    flow_dir = _flat_to_dir_indices(flow_to)
    upstream = _count_upstream(flow_dir)
    strahler, shreve = compute_stream_orders(flow_dir, upstream)

    biome = classify_biomes(temp, moist).copy()
    land = ~ocean_mask
    biome[ocean_mask] = 0
    biome[(biome == 0) & land] = 3

    river_mask = (flow_acc >= params["river_acc_min"]) & land & (~ice_mask)
    river_mask &= lake_id == 0

    rivers = extract_river_segments(
        flow_acc,
        flow_dir,
        strahler,
        shreve,
        basin_id,
        lake_id,
        ocean_mask,
        river_mask,
        seed=seed,
    )
    lakes = {
        "geoms": [],
        "basin_id": [],
        "area_km2": [],
        "elev_mean": [],
    }

    land_ratio = float(land.mean())
    num_river_cells = int(river_mask.sum())
    endorheic_ids = basin_id[basin_id < 0]
    num_endorheic = int(np.unique(endorheic_ids).size) if endorheic_ids.size else 0

    stats = {
        "land_ratio": land_ratio,
        "max_flow": int(flow_acc.max()),
        "num_river_cells": num_river_cells,
        "num_rivers": len(rivers["geoms"]),
        "num_lakes": int(lake_id.max()),
        "endorheic_basins": num_endorheic,
        "max_strahler": int(strahler[land].max()) if land.any() else 0,
        "max_shreve": int(shreve[land].max()) if land.any() else 0,
    }

    return {
        "elev": elev.astype(np.float32),
        "filled": filled.astype(np.float32),
        "hydro": hydro.astype(np.float32),
        "temp": temp,
        "moist": moist,
        "biome": biome.astype(np.uint8),
        "flow_acc": flow_acc,
        "flow_dir": flow_dir,
        "upstream": upstream,
        "strahler": strahler,
        "shreve": shreve,
        "basin_id": basin_id,
        "lake_id": lake_id,
        "rivers": rivers,
        "lakes": lakes,
        "rivers_mask": river_mask.astype(np.uint8),
        "ice_mask": ice_mask.astype(np.uint8),
        "stats": stats,
        "params": params,
    }


def export_dataset(out_dir: str | Path, seed: int, world: Dict[str, Any]) -> None:
    """Write rasters and vectors to an interchange-friendly directory."""
    out = Path(out_dir)
    out.mkdir(parents=True, exist_ok=True)
    rasters_dir = out / "rasters"
    vectors_dir = out / "vectors"
    rasters_dir.mkdir(parents=True, exist_ok=True)
    vectors_dir.mkdir(parents=True, exist_ok=True)

    elev = world["elev"]
    height, width = elev.shape
    affine = world_transform(width, height)

    write_geotiff(rasters_dir / "elev.tif", elev.astype(np.float32), affine)
    write_geotiff(rasters_dir / "filled.tif", world["filled"].astype(np.float32), affine)
    write_geotiff(rasters_dir / "hydro.tif", world["hydro"].astype(np.float32), affine)
    write_geotiff(rasters_dir / "temp.tif", world["temp"].astype(np.float32), affine)
    write_geotiff(rasters_dir / "moist.tif", world["moist"].astype(np.float32), affine)
    write_geotiff(rasters_dir / "flow_acc.tif", world["flow_acc"].astype(np.uint32), affine)
    write_geotiff(rasters_dir / "basin_id.tif", world["basin_id"].astype(np.int32), affine)
    write_geotiff(rasters_dir / "lake_id.tif", world["lake_id"].astype(np.int32), affine)
    write_geotiff(rasters_dir / "biome.tif", world["biome"].astype(np.uint8), affine)
    write_geotiff(rasters_dir / "ice_mask.tif", world["ice_mask"].astype(np.uint8), affine)
    write_geotiff(rasters_dir / "rivers_mask.tif", world["rivers_mask"].astype(np.uint8), affine)

    rivers = world.get("rivers", {})
    lakes = world.get("lakes", {})

    vector_files: dict[str, str] = {}
    if rivers and rivers.get("geoms"):
        write_parquet_wkb(
            vectors_dir / "rivers.parquet",
            rivers["geoms"],
            {
                "basin_id": rivers["basin_id"],
                "order_strahler": rivers["order_strahler"],
                "order_shreve": rivers["order_shreve"],
                "discharge": rivers["discharge"],
                "length_km": rivers["length_km"],
                "source_type": rivers["source_type"],
                "mouth_type": rivers["mouth_type"],
            },
        )
        vector_files["rivers"] = "vectors/rivers.parquet"

    if lakes and lakes.get("geoms"):
        write_parquet_wkb(
            vectors_dir / "lakes.parquet",
            lakes["geoms"],
            {
                "basin_id": lakes["basin_id"],
                "area_km2": lakes["area_km2"],
                "elev_mean": lakes["elev_mean"],
            },
        )
        vector_files["lakes"] = "vectors/lakes.parquet"

    manifest = {
        "version": "0.2",
        "seed": seed,
        "crs": "EPSG:4326",
        "width": width,
        "height": height,
        "files": {
            "rasters": {
                "elev": "rasters/elev.tif",
                "filled": "rasters/filled.tif",
                "hydro": "rasters/hydro.tif",
                "temp": "rasters/temp.tif",
                "moist": "rasters/moist.tif",
                "flow_acc": "rasters/flow_acc.tif",
                "basin_id": "rasters/basin_id.tif",
                "lake_id": "rasters/lake_id.tif",
                "biome": "rasters/biome.tif",
                "ice_mask": "rasters/ice_mask.tif",
                "rivers_mask": "rasters/rivers_mask.tif",
            },
            "vectors": vector_files,
        },
        "stats": world.get("stats", {}),
    }
    (out / "dataset.json").write_text(json.dumps(manifest, indent=2))
