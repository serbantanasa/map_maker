"""Portions generated by AI with human review.

Hydrology utilities for priority-flood filling, flow routing, and basin labelling.
"""

from __future__ import annotations

import heapq
from collections import deque
from typing import Deque, List, Tuple

import numpy as np

Array = np.ndarray

DIRS8: Tuple[Tuple[int, int], ...] = (
    (-1, -1),
    (-1, 0),
    (-1, 1),
    (0, -1),
    (0, 1),
    (1, -1),
    (1, 0),
    (1, 1),
)


def priority_flood_fill(elev: Array, ocean_mask: Array) -> Array:
    """Raise depressions so that every land cell has a drainage path."""
    h, w = elev.shape
    filled = elev.copy()
    visited = np.zeros_like(elev, dtype=bool)
    pq: List[Tuple[float, int, int]] = []

    def push(y: int, x: int) -> None:
        if not visited[y, x]:
            visited[y, x] = True
            heapq.heappush(pq, (float(filled[y, x]), y, x))

    for y in range(h):
        push(y, 0)
        push(y, w - 1)
    for x in range(w):
        push(0, x)
        push(h - 1, x)
    oy, ox = np.where(ocean_mask)
    for y, x in zip(oy, ox, strict=False):
        push(int(y), int(x))

    while pq:
        z, y, x = heapq.heappop(pq)
        for dy, dx in DIRS8:
            ny, nx = y + dy, x + dx
            if 0 <= ny < h and 0 <= nx < w and not visited[ny, nx]:
                visited[ny, nx] = True
                if filled[ny, nx] < z:
                    filled[ny, nx] = z
                heapq.heappush(pq, (float(filled[ny, nx]), ny, nx))
    return filled


def _multi_source_manhattan_distance(mask: Array) -> Array:
    """Return 4-neighbour distance to the nearest True cell (or boundary)."""
    h, w = mask.shape
    inf = np.int32(2**31 - 1)
    dist = np.full((h, w), inf, dtype=np.int32)
    queue: Deque[Tuple[int, int]] = deque()

    ys, xs = np.where(mask)
    for y, x in zip(ys, xs, strict=False):
        dist[y, x] = 0
        queue.append((int(y), int(x)))

    for y in range(h):
        for x in (0, w - 1):
            if dist[y, x] > 0:
                dist[y, x] = 0
                queue.append((y, x))
    for x in range(w):
        for y in (0, h - 1):
            if dist[y, x] > 0:
                dist[y, x] = 0
                queue.append((y, x))

    while queue:
        y, x = queue.popleft()
        dnext = dist[y, x] + 1
        if y > 0 and dist[y - 1, x] > dnext:
            dist[y - 1, x] = dnext
            queue.append((y - 1, x))
        if y + 1 < h and dist[y + 1, x] > dnext:
            dist[y + 1, x] = dnext
            queue.append((y + 1, x))
        if x > 0 and dist[y, x - 1] > dnext:
            dist[y, x - 1] = dnext
            queue.append((y, x - 1))
        if x + 1 < w and dist[y, x + 1] > dnext:
            dist[y, x + 1] = dnext
            queue.append((y, x + 1))
    return dist


def build_hydrosurface(
    filled: Array, ocean_mask: Array, slope_eps: float = 1e-3
) -> Tuple[Array, Array]:
    """Return a gently sloped surface and the normalized distance field."""
    dist = _multi_source_manhattan_distance(ocean_mask).astype(np.float32)
    if dist.max() > 0:
        dist /= float(dist.max())
    hydro = filled + slope_eps * dist
    return hydro.astype(np.float32), dist


def flowdir_d8(hydro: Array, ocean_mask: Array, dist: Array | None = None) -> Array:
    """Return flat indices of the steepest descent neighbour (or -1)."""
    h, w = hydro.shape
    flat_to = np.full(h * w, -1, dtype=np.int32)
    for y in range(h):
        for x in range(w):
            i = y * w + x
            if ocean_mask[y, x]:
                flat_to[i] = -1
                continue
            z = hydro[y, x]
            best = None
            bestz = z
            for dy, dx in DIRS8:
                ny, nx = y + dy, x + dx
                if 0 <= ny < h and 0 <= nx < w:
                    nz = hydro[ny, nx]
                    dist_better = False
                    if dist is not None:
                        dist_better = dist[ny, nx] < dist[y, x]
                    if (nz < bestz) or (nz == bestz and dist_better):
                        bestz = nz
                        best = ny * w + nx
            if best is None:
                for dy, dx in DIRS8:
                    ny, nx = y + dy, x + dx
                    if 0 <= ny < h and 0 <= nx < w and ocean_mask[ny, nx]:
                        best = ny * w + nx
                        break
            flat_to[i] = -1 if best is None else int(best)
    return flat_to.reshape(h, w)


def flow_accumulation(flat_to: Array) -> Array:
    """Sum contributing area for each cell given downstream pointers."""
    h, w = flat_to.shape
    n = h * w
    to_flat = flat_to.ravel()
    acc = np.ones(n, dtype=np.uint32)
    indeg = np.zeros(n, dtype=np.int32)
    for i, j in enumerate(to_flat):
        if j >= 0:
            indeg[j] += 1
    queue: Deque[int] = deque(i for i in range(n) if indeg[i] == 0)
    order: List[int] = []
    while queue:
        i = queue.popleft()
        order.append(i)
        j = to_flat[i]
        if j >= 0:
            indeg[j] -= 1
            if indeg[j] == 0:
                queue.append(j)
    if len(order) < n:
        seen = set(order)
        order.extend(i for i in range(n) if i not in seen)
    for i in order:
        j = to_flat[i]
        if j >= 0:
            acc[j] += acc[i]
    return acc.reshape(h, w)


def label_lakes(filled: Array, original_elev: Array, ocean_mask: Array) -> Array:
    """Label 8-connected inland depressions that needed filling."""
    h, w = original_elev.shape
    lake_mask = (filled > original_elev) & (~ocean_mask)
    labels = np.zeros((h, w), dtype=np.int32)
    current = 0
    for y in range(h):
        for x in range(w):
            if lake_mask[y, x] and labels[y, x] == 0:
                current += 1
                queue: Deque[Tuple[int, int]] = deque([(y, x)])
                labels[y, x] = current
                while queue:
                    cy, cx = queue.popleft()
                    for dy, dx in DIRS8:
                        ny, nx = cy + dy, cx + dx
                        if (
                            0 <= ny < h
                            and 0 <= nx < w
                            and lake_mask[ny, nx]
                            and labels[ny, nx] == 0
                        ):
                            labels[ny, nx] = current
                            queue.append((ny, nx))
    return labels


def label_basins(flat_to: Array, ocean_mask: Array, lake_id: Array) -> Array:
    """Assign basin IDs: 0 for ocean-draining, <0 for endorheic sinks."""
    h, w = flat_to.shape
    n = h * w
    to_flat = flat_to.ravel()
    ocean_flat = ocean_mask.ravel()
    basin = np.full(n, 2**31 - 1, dtype=np.int32)

    sinks = np.where((to_flat < 0) & (~ocean_flat))[0]
    for k, idx in enumerate(sinks, start=1):
        basin[idx] = -k
    basin[ocean_flat] = 0

    order = np.arange(n, dtype=np.int32)
    for _ in range(3):
        for i in order:
            if basin[i] != 2**31 - 1:
                continue
            j = to_flat[i]
            if j < 0:
                basin[i] = 0
            elif basin[j] != 2**31 - 1:
                basin[i] = basin[j]

    unassigned = basin == 2**31 - 1
    basin[unassigned] = 0

    basin_2d = basin.reshape(h, w)
    # Lakes inherit the basin of any downstream neighbour.
    lake_labels = np.unique(lake_id)
    for lid in lake_labels:
        if lid <= 0:
            continue
        ys, xs = np.where(lake_id == lid)
        if len(ys) == 0:
            continue
        # pick the lowest downstream pointer among lake cells
        downstream_ids = []
        for y, x in zip(ys, xs, strict=False):
            target = to_flat[y * w + x]
            if target >= 0:
                downstream_ids.append(basin[target])
        if downstream_ids:
            basin_2d[lake_id == lid] = downstream_ids[0]

    return basin_2d


def breach_endorheic_basins(
    flow_to: Array,
    basin_id: Array,
    ocean_mask: Array,
    dist: Array,
    hydro: Array,
    flow_acc: Array,
    river_threshold: int,
) -> bool:
    """Carve outlets for large endorheic basins using the ocean distance gradient."""

    h, w = flow_to.shape
    to_flat = flow_to.ravel()
    basin_flat = basin_id.ravel()
    ocean_flat = ocean_mask.ravel()
    dist_flat = dist.ravel()
    hydro_flat = hydro.ravel()
    acc_flat = flow_acc.ravel()

    changed = False

    for label in np.unique(basin_flat):
        if label >= 0:
            continue
        basin_cells = np.flatnonzero(basin_flat == label)
        if basin_cells.size == 0:
            continue
        if acc_flat[basin_cells].max() < river_threshold:
            continue

        sink_idx = basin_cells[np.argmax(acc_flat[basin_cells])]
        current = int(sink_idx)
        visited: set[int] = set()

        for _ in range(h * w):
            if current in visited:
                break
            visited.add(current)

            if ocean_flat[current]:
                break

            y, x = divmod(current, w)
            best_idx = -1
            best_key = (dist_flat[current], hydro_flat[current])

            for dy, dx in DIRS8:
                ny, nx = y + dy, x + dx
                if 0 <= ny < h and 0 <= nx < w:
                    nidx = ny * w + nx
                    key = (dist_flat[nidx], hydro_flat[nidx])
                    if key < best_key:
                        best_key = key
                        best_idx = int(nidx)

            if best_idx == -1:
                # fallback: absolute best neighbour by distance even if equal
                candidates = [
                    int((y + dy) * w + (x + dx))
                    for dy, dx in DIRS8
                    if 0 <= y + dy < h and 0 <= x + dx < w
                ]
                if not candidates:
                    break
                best_idx = min(candidates, key=lambda idx: (dist_flat[idx], hydro_flat[idx]))
                if best_idx == current:
                    break

            if best_idx in visited:
                break

            if to_flat[current] != best_idx:
                to_flat[current] = best_idx
                changed = True

            current = best_idx

            if ocean_flat[current]:
                break

    return changed
